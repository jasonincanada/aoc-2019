{-# Language LambdaCase #-}

module Day07 (part1, part2) where

{-  Advent of Code 2019 - Day 7 - https://adventofcode.com/2019/day/7 -}

import           Control.Arrow       ((>>>))
import           Control.Monad.State
import           Data.Bool           (bool)
import           Data.Function       ((&))
import qualified Data.IntMap as IM
import           Data.List           (permutations)
import           Data.List.Split     (splitOn)


{- Types -}

type Address = Int
type Opcode  = Int
type Input   = IM.IntMap Opcode

data Mode    = Position | Immediate

-- the state of the computer at any time
data Computer = Computer { address :: Address          -- instruction pointer
                         , memory  :: IM.IntMap Opcode -- RAM
                         , mode1   :: Mode             -- modes set by latest instruction
                         , mode2   :: Mode
                         , part    :: Int              -- 1 or 2
                         , inputs  :: [Int]            -- list of inputs for opcode 3
                         , outputs :: [Int]            -- outputs generated by opcode 4
                         }

data StepResult = SignalOut Int   -- the amp has outputted a signal
                | Halt            -- a 99 opcode halted the amp

data Output     = Output Int

instance Show Output where
  show (Output value) = show value


{- Parsing -}

parse :: String -> Input
parse = split >>> map read >>> toMap
  where
    split = splitOn ","
    toMap = IM.fromList . zip [0..]


{- Part 1 -}

type Phase  = Int  -- phase setting
type Signal = Int  -- amp input or output signal

calc1 :: Input -> Output
calc1 opcodes = Output result
  where
    result = maximum [ try ps | ps <- permutations [0,1,2,3,4] ]

    try :: [Phase] -> Signal
    try phases = foldl run 0 phases
      where
        run :: Signal -> Phase -> Signal
        run s p = case runState process start of
                    (Halt, amp) -> head (outputs amp)
          where
            start = Computer 0 opcodes Position Position 1 [p,s] []

    -- foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b


process :: State Computer StepResult
process = seek 0 >> step


step :: State Computer StepResult
step = do
  ip <- gets address
  instruction <- readAt ip

  let opcode = instruction `mod` 100

  setMode 1 (getDigit 3 instruction == 1)
  setMode 2 (getDigit 4 instruction == 1)

  case opcode of

    -- add
    1  -> do add1   <- param 1
             add2   <- param 2
             destAt <- readAt (ip+3)

             update destAt (add1+add2)

             jump 4
             step


    -- multiply
    2  -> do mul1   <- param 1
             mul2   <- param 2
             destAt <- readAt (ip+3)

             update destAt (mul1*mul2)

             jump 4
             step


    -- save input
    3  -> do int    <- input
             destAt <- readAt (ip+1)

             update destAt int

             jump 2
             step


    -- output
    4  -> do value <- param 1
             part  <- gets part

             output value
             jump 2

             if part == 1
             then step
             else return (SignalOut value)


    -- jump-if-true
    5  -> do param1 <- param 1

             if param1 /= 0
             then do param 2 >>= seek
                     step

             else do jump 3
                     step


    -- jump-if-false
    6  -> do param1 <- param 1

             if param1 == 0
             then do param 2 >>= seek
                     step

             else do jump 3
                     step


    -- less than
    7  -> do param1 <- param 1
             param2 <- param 2
             param3 <- readAt (ip+3)

             update param3 (bool 0 1 $ param1 < param2)

             jump 4
             step


    -- equals
    8  -> do param1 <- param 1
             param2 <- param 2
             param3 <- readAt (ip+3)

             update param3 (bool 0 1 $ param1 == param2)

             jump 4
             step


    -- quit
    99 -> return Halt


-- get the nth digit from the right of a base-10 integer
getDigit :: Int -> Int -> Int
getDigit i number = number `div` (10^(i-1)) `mod` 10

jump :: Int -> State Computer ()
jump n = do
  ip <- gets address
  seek (ip+n)

-- move the instruction pointer
seek :: Address -> State Computer ()
seek addy = modify (\c -> c { address = addy } )

-- get an opcode at an address
readAt :: Address -> State Computer Opcode
readAt addy = gets (memory >>> flip (IM.!) addy)

-- get a parameter
param :: Int -> State Computer Int
param i = do
  ip <- gets address
  readAt (ip+i) >>= getValue i

  where
    -- in Immediate mode, return the value
    -- in Position mode, consider it an address and return what's at the address
    getValue :: Int -> Int -> State Computer Int
    getValue n val
      | n == 1 = go mode1
      | n == 2 = go mode2
      where
        go m = gets m >>= \case Position  -> readAt val
                                Immediate -> return val

-- change an opcode at a position
update :: Address -> Int -> State Computer ()
update addy opcode = do
  memory' <- IM.insert addy opcode <$> gets memory
  modify (\c -> c { memory = memory' })

-- add a value to the input queue
addInput :: Int -> State Computer ()
addInput i = modify (\c -> c { inputs = inputs c ++ [i] } )

-- get a value from the input
input :: State Computer Int
input = do
  (i:is) <- gets inputs
  modify (\c -> c { inputs = is })
  return i

output :: Int -> State Computer ()
output value = do
  outputs <- gets outputs
  modify (\c -> c { outputs = value : outputs })

setMode :: Int -> Bool -> State Computer ()
setMode 1 mode = modify (\c -> c { mode1 = bool Position Immediate mode })
setMode 2 mode = modify (\c -> c { mode2 = bool Position Immediate mode })


{- Part 2 -}

calc2 :: Input -> Output
calc2 opcodes = Output result
  where
    result = maximum [ try ps | ps <- permutations [5,6,7,8,9] ]

    try :: [Phase] -> Signal
    try phases = go amps 0  -- start with the first amp
                         0  -- the first input signal is 0
      where
        go :: IM.IntMap Computer -> Int -> Signal -> Signal
        go amps i signal =

            case result of
              SignalOut sig -> go amps' (next i) sig
              Halt          -> head (outputs $ amps' IM.! 4) -- last output from amp E

          where
            (result, state) = runState (addInput signal >> step)
                                       (amps IM.! i)

            -- save this state to the map so we can resume from here next time
            amps' = IM.insert i state amps

            -- cycle to the next amp, wrapping from E back to A
            next 4 = 0
            next n = n+1


        -- init each amp with its phase setting
        amps :: IM.IntMap Computer
        amps = IM.fromList $ zip [ 0.. ]
                                 [ start p | p <- phases ]

        start phase = Computer 0
                               opcodes
                               Position
                               Position
                               2
                               [phase]  -- load up the phase setting as its first input
                               []



{- Operations -}

part1 :: String -> String
part1 = parse >>> calc1 >>> show
part2 = parse >>> calc2 >>> show

