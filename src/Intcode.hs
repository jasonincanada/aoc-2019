{-# Language LambdaCase, MultiWayIf, ViewPatterns #-}

{-  Advent of Code 2019 - Intcode Computer!  -}

module Intcode (
  -- type constructors
  Address(..), Intcode(..), RAM, StepResult(..), Value(..),

  -- functions
  initIntcode, addInput, sendInput, step, stepInput
) where


import           Control.Arrow       ((>>>))
import           Control.Monad.State
import           Data.Bool           (bool)
import qualified Data.Map as M


{- Types -}

data Address = Addr Int
               deriving (Eq, Ord)

-- interpretable as either an integer value or an opcode
data Value   = Value Int

data Mode    = Position | Relative | Immediate
type RAM     = M.Map Address Value

-- the state of the computer at any time
data Intcode = Intcode { address :: Address          -- instruction pointer
                       , memory  :: RAM
                       , base    :: Address          -- relative base
                       , mode1   :: Mode             -- modes set by latest instruction
                       , mode2   :: Mode
                       , mode3   :: Mode
                       , inputs  :: [Value]          -- list of inputs for opcode 3
                       , outputs :: [Int]            -- outputs generated by opcode 4
                       , signal  :: Bool             -- return from step with signal?
                       }

data StepResult = SignalOut Int   -- the program has output a value
                | Halt            -- a 99 opcode stopped the program



-- initialize a computer with a given program and list of inputs
initIntcode :: RAM -> [Value] -> Bool -> Intcode
initIntcode ram inputs signals = Intcode (Addr 0)
                                         ram
                                         (Addr 0)
                                         Position
                                         Position
                                         Position
                                         inputs
                                         []
                                         signals


{- Intcode state machine -}

step :: State Intcode StepResult
step = do
  ip <- gets address
  Value instruction <- readAt ip

  let opcode = instruction `mod` 100

  setMode 1 (getDigit 3 instruction)
  setMode 2 (getDigit 4 instruction)
  setMode 3 (getDigit 5 instruction)

  case opcode of

    -- add
    1  -> do Value add1 <- param 1
             Value add2 <- param 2
             addr       <- dest  3

             update addr (Value $ add1+add2)

             jump 4
             step


    -- multiply
    2  -> do Value mul1 <- param 1
             Value mul2 <- param 2
             addr       <- dest  3

             update addr (Value $ mul1*mul2)

             jump 4
             step


    -- save input
    3  -> do val  <- input
             addr <- dest 1

             update addr val

             jump 2
             step


    -- output
    4  -> do Value val <- param 1
             signals   <- gets signal

             output (Value val)

             jump 2

             if | signals   -> return $ SignalOut val
                | otherwise -> step


    -- jump-if-true
    5  -> do Value p1 <- param 1

             if | p1 /= 0   -> do param 2 >>= (toAddr >>> seek)
                                  step
                | otherwise -> do jump 3
                                  step


    -- jump-if-false
    6  -> do Value p1 <- param 1

             if | p1 == 0   -> do param 2 >>= (toAddr >>> seek)
                                  step
                | otherwise -> do jump 3
                                  step


    -- less than
    7  -> do Value p1 <- param 1
             Value p2 <- param 2
             addr     <- dest  3

             update addr (Value $ bool 0 1 (p1 < p2))

             jump 4
             step


    -- equals
    8  -> do Value p1 <- param 1
             Value p2 <- param 2
             addr     <- dest  3

             update addr (Value $ bool 0 1 (p1 == p2))

             jump 4
             step


    -- adjust relative base
    9  -> do param 1 >>= adjustBase

             jump 2
             step


    -- quit
    99 -> return Halt


-- get the nth digit from the right of a base-10 integer
getDigit :: Int -> Int -> Int
getDigit i number = number `div` (10^(i-1)) `mod` 10

jump :: Int -> State Intcode ()
jump n = do
  ip <- gets address
  seek (hop n ip)

-- adjust an address by the given number of steps
hop :: Int -> Address -> Address
hop n (Addr a) = Addr (n+a)

toAddr :: Value -> Address
toAddr (Value a) = Addr a

-- move the instruction pointer
seek :: Address -> State Intcode ()
seek a = modify (\c -> c { address = a } )

-- adjust the relative base
adjustBase :: Value -> State Intcode ()
adjustBase (Value n) = modify (\c -> c { base = hop n (base c) })

-- get an opcode at an address
readAt :: Address -> State Intcode Value
readAt a = do
  memory <- gets memory

  case M.lookup a memory of
    Nothing -> return $ Value 0
    Just op -> return op

-- get a parameter value (which can be used in addition, mult, etc)
param :: Int -> State Intcode Value
param i = do
  ip <- gets address
  readAt (hop i ip) >>= getValue i

  where
    -- in Immediate mode, return the value
    -- in Position mode, consider it an address and return what's at the address
    -- in Relative mode, consider it an address and return what's at the address+base
    getValue :: Int -> Value -> State Intcode Value
    getValue n (Value val)
      | n == 1 = go mode1
      | n == 2 = go mode2
      | n == 3 = go mode3
      where
        go :: (Intcode -> Mode) -> State Intcode Value
        go m = gets m >>= \case Immediate -> return $ Value val
                                Position  -> readAt $ Addr val
                                Relative  -> gets base >>= (hop val >>> readAt)


-- get a parameter representing a destination address for writing by the calling code
dest :: Int -> State Intcode Address
dest i = do
  ip <- gets address
  readAt (hop i ip) >>= getValue i

  where
    -- in Position mode, consider it an address and return it
    -- in Relative mode, consider it a relative address and return it+base
    getValue :: Int -> Value -> State Intcode Address
    getValue n (Value val)
      | n == 1 = go mode1
      | n == 2 = go mode2
      | n == 3 = go mode3
      where
        go :: (Intcode -> Mode) -> State Intcode Address
        go m = gets m >>= \case Position  -> return $ Addr val
                                Relative  -> gets base >>= (hop val >>> return)


-- change an opcode at a position
update :: Address -> Value -> State Intcode ()
update a v = do
  memory' <- M.insert a v <$> gets memory
  modify (\c -> c { memory = memory' })

-- get a value from the input
input :: State Intcode Value
input = do
  (i:is) <- gets inputs
  modify (\c -> c { inputs = is })
  return i

-- add a value to the input queue
addInput :: Int -> State Intcode ()
addInput val = modify (\c -> c { inputs = inputs c ++ [Value val] } )

-- exported to calling module
sendInput :: Int -> Intcode -> Intcode
sendInput val comp = execState (addInput val) comp

stepInput :: Int -> State Intcode StepResult
stepInput val = addInput val >> step

output :: Value -> State Intcode ()
output (Value v) = do
  outputs <- gets outputs
  modify (\c -> c { outputs = v : outputs })

setMode :: Int -> Int -> State Intcode ()
setMode 1 mode = modify (\c -> c { mode1 = toMode mode })
setMode 2 mode = modify (\c -> c { mode2 = toMode mode })
setMode 3 mode = modify (\c -> c { mode3 = toMode mode })

toMode 0 = Position
toMode 1 = Immediate
toMode 2 = Relative

